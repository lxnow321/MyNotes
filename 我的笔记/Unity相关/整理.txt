整理

项目经验深入，问得比较细（做过的东西，资源加载，打包，jsb框架，ab加载策略和卸载策略）
数据结构，语言基础，python等  排序，树，hash表

hash表：构造方法：直接定址法 数字分析法  平方取中法 折叠法 除留取余法 随机数法
冲突解决方法： 开放定址 再哈希 链地址法 建立一个公共溢出区


业务：
1.技能编辑器优化
2.飞行系统
3.热更loading,logo
4.技能调试

5.战斗重现机制
(1)保存战斗回合数据

(2)读取本地文件重现战斗


项目架构：
1.资源加载
2.缓存池
3.打包策略
4.JSB框架



移植《超萌骑士团》项目优化检测工具；
图集优化拆分，登录加载优化，动画优化拆分单独打包加载及浮点精度裁剪，优化GC，Drawcall；
制作战斗回放功能，处理技能战斗问题；
性能分析，优化。

**登录加载优化：
优化背景：
(1)首次登陆时加载角色场景过长，导致玩家体验比较差。
(2)优化登录场景加载耗时，让玩家能快速从登录状态进入到场景中游戏

原因：首次登陆从服务器中下载静态导表数据，下载和加载过程耗时比较长。

优化：
(1)打包时注意登陆一次游戏仿真服，将静态导表数据下载，然后再打资源ab，即可以将最新版本的静态导表数据打到包内，可以有效避免玩家第一次登陆时的较长的静态导表数据的下载过程。
(2)原本登录进入场景时都通过主线程进行，依赖一些基础数据（帮派，背包，仓库，时装，邮件，好友，宠物，任务）加载完成后再判断是否可加载场景。通过代码分析发现:
 (2.1)主线程加载，由于业务堆积，许多业务过分依赖登录初始化过程，将一些可必要的初始化过程放到该部分。而又由于没有强调加载顺序，导致一些非必数据在加载依赖的数据之前进行初始化；
 (2.2)原本依赖的数据有些没有必要在进入场景前就去加载，可减少该部分依赖（如：帮派，背包，仓库，邮件，好友，宠物等）这些可以放到场景加载完成后在后台做请求，打开界面如果发现数据未初始化，可等待初始化完成后再开放打开
 (2.3)使用协程，不在直接在主线程中做加载，使用协程将数据加载分步加载，避免阻塞

知识点：
协程，静态导表加载

协程：
(1)协程不是多线程，协程还是在主线程中
(2)协程不只是做简单的延迟作用
(3)协程真正的用途是分步做一件比较耗时的事情，比如游戏中加载资源。
(4)可再补充一下“协程”的机制和原理

静态导表加载：
(1)静态导表数据分两部分加载，一部分是在渠道加载完成后去检测更新的预加载部分，有些数据是在还未登录到游戏中需要用到的，如主角信息等。



登录流程：


制客户端工作规范，美术资源规范，与其他部门协调沟通；
负责组内新同事面试和培训，合理分配及指导完成阶段性开发任务；
基础框架升级（Unity版本，资源加载释放管理，打包工具）；
战斗系统优化扩展，技能编辑器，剧情编辑器，多段飞行系统；作
UI冗余资检测工具，Drawcall优化检测，资源导入检测等工具。


基础框架升级：
1.unity版本从4.6.9升级到5.4.4f1版本
2.资源加载释放管理：
  2.1：引入PathologicalGames的缓存池管理PoolManager
  2.2：AssetPipline资源流水线。自动设置bundlename，
  2.3：图集引用计数；改写UISprite以及其他引用了Atlas的组件，将其加入到图集引用管理AtlasManager。当UI中引用某个图集时，引用计数+1，当移除引用时，引用计数-1。并通过当前的引用计数是否为0判断是否需要卸载UI资源。原本加载的UI图集未管理时，每次使用后都不能找到很好的时机去卸载，导致游戏过程中该部分图集所占用的内存会越积越多。有了引用计数，那么可以在不需要使用该图集后，从内存中卸载该图集。
3. 打包工具：
  3.1：打包由原来自己维护资源依赖做打包，升级为Unity5后，使用Unity5自带生成Manifest依赖关系打包。



Unity4.x与Unity5.x的打包的不同

1.unity5.x新增了一个总的Manifest文件用于管理资源之间的依赖（5.3之后），unity4.x则需要开发者手动进行资源间依赖的管理（PushAssetDependencies/PopAssetDependencies）。
2.由于上述引入的manifest文件，我们可以实现增量更新，只处理更新有变化的部分。而依赖该变化的资源部分不必更新。


LZMA : Unity默认的压缩方式，压缩比较高，所以解压时间也相对较长。
LZ4 ： 基于块压缩，压缩比不高，解压时间短。
不压缩： 略
针对上述两种压缩方式，如shader,uiatlas,uifont,uiprefab,uitexture等资源较小，加载响应需要比较及时的资源。采用LZ4,使用LoadFromFile，同步加载方式。audio,config,effect,image,model,scene等文件较大的资源，使用LZMA压缩方式，减小包体大小，且使用LoadFromFileAsync异步加载。

LZ4:  shader,uiatlas,uifont,uiprefab,uitexture

LZMA： audio,config,effect,image,model,scene

优化内容：
1.Drawcall优化
(1)drawcall优化原理，从UIPanel UIWidget，UIDrawcall的关系着手
(2)增加检测工具，静态检测预期可优化drawcall数量。增加辅助工具，调整同Panel材质depth高度
(3)动静分离
(4)优化GC:枚举类型做字典key需要实现IEquolityComparer接口类传入字典，并实现Equals和GetHashCode方法。

2.动画优化-
(1).从fbx中抽离anim文件，单独打包；优化anim文件大小，裁剪浮点数精度
(2).配套工具：分离clip，迁移目录，裁剪anim浮点数，动画控制器挂载管理,anim自动导入规范检测

使用的Unity类:
//从fbx中将animationclip抽出来
AnimationClip newClip = new AnimationClip();
EditorUtility.CopySerialized(clip, newclip);
AssetDatabase.DeleteAsset(pat);
AssetDatabase.CreateAsset(newclip, path);

AnimationClipCurveData[] curves = AnimationUtility.GetAllCurves(clip)





遇到的问题：
1.小米android测试时，崩溃率比较高（DOTWEEN机制导致）


***纹理压缩选择
Android 
ETC1 OpenGL ES2.0支持，移动GPU均支持的一种纹理压缩格式，但不支持Alpha通道，需要将纹理的rgb与alpha通道分离成两张贴图，通过shader进行两张贴图采样。Unity5.4.3版本之后提供了官方支持。

ETC2 只有OpenGL ES3.0支持，且支持alpha通道。如果使用ETC2，那么么旧的OpenGL ES2.0的机型将不被支持，需要考虑实际项目的最低机型选择。

iOS
PVRTC PowerVR架构独有的压缩格式，所有IOS平台都支持。支持2位或4位像素，支持alpha通道和不支持alpha通道选择。长宽相等且为2的N次幂。压缩效果后贴图失真严重。（当前项目需要还是做rgb与alpha的分离）

ASTC 
从IOS9(A8架构)Apple 手机开始支持ASTC压缩格式 ，iphone6/plus以上机型可用。相对于PVRTC2/4而言，ASTC(4X4)的压缩比会增加到0.25，不过显示效果也会好很多，而且不需要把图片设置为方形。


***美术资源规范

1.资源命名
(1)资源不能有中文，空格等特殊字符
(2)svn上资源命名需加上前缀做功能区分，如通用UI加common_xx，玩家相关使用Player_xx等利于辨识
(3)svn上的ui资源尽量与本地保持一致，如程序需根据功能做调整的，需同步更新svn美术资源。利于资源查找及更新迭代。
(4)新功能或UI迭代，美术效果图详细标注对于资源名称，字体参数等。同时出一套与制定的屏幕宽高一致的示意图，用于资源大小和位置确定。

2.除需要用双面材质表现的物体之外，其他物体不能使用双面材质

3.模型
(1)模型面数：主角单个小于5k面，场景总面数均值在50-60k，最高100k。其他怪物1k左右


设定好 3dmax 导出模型的比例标尺，最好与 Unity 大小 1:1；场景总面数均值5-6w左右（大部分），最高10w（少部分），单个模型300-1500面，摄像机可见部分2w以下，导出去除废点，多余的法线（如果没用的话），尽量单面；场景总面数还要看同屏战斗人数多少做调整，Drawcall最好不超过50，一边给角色和特效留下空间，总 Drawcall 不要超过250这个尽量保证；场景物体每个模型一个材质球，贴图256为主，正方形，pot(长宽2的倍数)；严格限制场景中透明片的大小和重叠的个数，尽量少用，减少面积；角色面数部分，主角1500以下；特殊boss2000以下；精英怪物1000面以下；普通怪物800面以下；每个角色一个材质，除了特殊部件（翅膀等）一律不使用透明材质；贴图长宽相等，符合pot，128-256为主，最大不超过512；去除 IK 节点和所有不必要的网格，对齐模型中心点与坐标原点；预先规定好角色需要换装的所有节点名称，并且将需要换装的部分规定好并制作时拆开；（建议将脸部单独拆卡，脸部可增加面数）；角色骨骼30-35根为主，特殊大boss适当增加，超过40慎重考虑；可以考虑动画帧率10帧每秒，视具体情况或者不限制；粒子单个发射器不超过50，每个特效最好10个粒子以下，同屏不超过500（200太低难以达到），尽量减少材质和粒子种类，大小，面积，层叠数等，粒子真的很费；摄像机一定要调整远近裁剪面，尽量降低远近裁剪面的距离，默认数值过大，也千万不要图方便设置比如 0.1-2000这种，该数值极大影响低端机的深度缓存精度，引起过近的物体穿插闪烁；使用最简单的线性雾，同时善用雾效和摄像机的 culldistant 功能，裁剪掉雾效淹没出的场景部件；可向程序提出贴图导入自动处理工具，比如角色贴图：普通贴图 _D 结尾，法线贴图 _N 结尾，导入时工具自动设置大小和格式；如果某个资源大于5MB，那么要仔细查看是否真的必要；如果成使用工具完成的资源检查和设置，那么都尽量提出需求让程序满足；最好有个人专门负责检查和整理资源；



